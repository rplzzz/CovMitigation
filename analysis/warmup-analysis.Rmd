---
title: "R Notebook"
output: html_notebook
---

```{r setup}
library(doParallel)
library(dplyr)
library(here)
library(metrosamp)
library(ggplot2)
library(ggthemes)
library(tidyr)
library(CovMitigation)

registerDoParallel(8)

mkdensplt <- function(samps) {
  varnames <- colnames(samps)
  pltdata <- pivot_longer(as.data.frame(samps), everything(), names_to = 'parameter')
  pltdata$parameter <- factor(pltdata$parameter, levels=varnames, ordered=TRUE)
  ggplot(data=pltdata, aes(x=value)) + geom_density(fill='LightGrey', alpha=0.5) + facet_wrap(~parameter, scales='free') +
    theme_bw()
}

set.seed(867-5309)
```

```{r loaddata}
datadir <- here('analysis', 'mcmc-rslts', 'mcmc-test-v3')
warmup_files <- list.files(path=datadir, pattern='mcmc-ckpt.*\\.rds', full.names=TRUE)

warmups <- lapply(warmup_files, readRDS)
warmups <- recover_ckpt(warmups)

cwarmups <- metrosamp2coda(warmups, 2500)
```

## Expectation value and credible intervals
```{r basicanalysis}
cat('\nAcceptance ratio by chain:\n')
sapply(warmups, accrate)
cat('\nOverall acceptance rate:\n')
accrate(warmups)
cat('\nEffective samples:\n')
print(neff(warmups))
cat('Expectation values:\n')
print(signif(EV(warmups), 2))
cat('\nCredible intervals:\n')
print(signif(CI(warmups), 2))
cat('\nRhat statistic:\n')
coda::gelman.diag(cwarmups)
```

## Density plots

```{r densplots}
allsamps <- getsamples(warmups, thinto=1600)
mkdensplt(allsamps)
```

```{r sampleruns}
Nsamp <- 250
parmsamps <- rsample(warmups, Nsamp)
runparms <- function(parms, scenname) {
  modparms <- parms[c('eta','xi','zeta', 'A0', 'D0', 'Ts', 'I0', 'mask_effect')]
  day_zero <- 30
  raw <- run_scenario(270, as.list(modparms), scenarioName = scenname)
  totalUVA <- 
    group_by(raw, time, scenario) %>% 
    summarise(
      popmkt = sum(population*marketFraction),
      newCases = sum(newCases*marketFraction),
      newSympto = sum(newSympto * marketFraction),
      PopSympto = sum(PopSympto*marketFraction),
      PopInfection = sum(PopInfection*marketFraction),
      fracInfection = PopInfection / popmkt,
      PopCumulInfection = sum(PopCumulInfection*marketFraction),
      fracCumulInfection = PopCumulInfection/popmkt
    ) %>%
    ungroup()
  dt <- totalUVA$time + day_zero
  dateout <- dt + as.Date('2020-01-01')
  mutate(totalUVA, time=dt, date=dateout)
}

sample_runs <- 
  lapply(seq(1,Nsamp), 
         function(i) {
           parms <- parmsamps[i,]
           runparms(parms, as.character(i))
         }) %>%
  bind_rows()

ev_run <- runparms(EV(warmups), 'EV')
map_run <- runparms(MAP(warmups), 'MAP')
```

Comparison to model observation.  Note both Franklin City and Charlottesville City
are missing their mobility data, which hurts our ability to pick up the July uptick
in cases in those localities.
```{r modobs}
mapev <- rbind(EV(warmups), MAP(warmups))
viscounties <- c('AlbemarleCounty', 'Charlottesvillecity', 'NelsonCounty',  ## Thomas Jefferson district
                 'FairfaxCounty', 'ArlingtonCounty', 'PrinceWilliamCounty',  ## Northern Virginia
                 'Richmondcity', 'HenricoCounty', 'ChesterfieldCounty',      ## Richmond area
                 'Franklincity', 'Suffolkcity', 'VirginiaBeachcity'         ## Tidewater
)
plt_modobs(mapev, c('EV', 'MAP'), counties = viscounties, default_parms=list(day_zero=30)) + scale_color_solarized()
plt_projections(mapev, c('EV', 'MAP'), what='PopInfection') + scale_color_solarized()
```

```{r ribbonplot}
strtdate <- as.Date('2020-07-01')
enddate <- as.Date('2020-10-01')
ci_by_date <- 
  filter(sample_runs, date >= strtdate, date < enddate) %>%
  #mutate(time = as.numeric(date-strtdate)) %>%
  group_by(date) %>%
  summarise(nslo = quantile(newSympto, 0.1), nshi = quantile(newSympto, 0.9)) %>%
  ungroup()

pltev <- filter(ev_run, date >= strtdate, date < enddate)

rplt <- 
  ggplot(data=pltev, aes(x=date)) + 
  geom_line(aes(y=newSympto), size=1.2) +
  geom_ribbon(data=ci_by_date, aes(ymin=nslo, ymax=nshi), alpha=0.5) +
  theme_bw()
print(rplt)
```

## Improving the sampling

The acceptance rate is really high, which is contributing to both poor sampling
efficiency and poor mixing.  Ideally we would want to make the sampling steps
large enough that the chains might be able to mix, but that may give us an 
acceptance rate that is too low, but it's worth a try.

```{r cor}
covm <- cov(allsamps)
signif(covm,3)
```

## Future scenarios

```{r futscen}
mapparms <- MAP(warmups)
mapfut <- c(as.list(mapparms), scenario='future')
map_fut_run <- runparms(mapfut, 'RTN future')
jan01 <- as.Date('2020-01-01')

plt <- dplyr::bind_rows(dplyr::mutate(map_run, scenario='Frozen future', date=time+jan01), 
                        dplyr::mutate(map_fut_run, date=time+jan01))

ggplot(plt, aes(x=date, y=fracInfection, color=scenario)) + geom_line(size=1.2) +
  ggthemes::scale_color_solarized() +
  theme_bw()
```

## Analysis of transmissibility

Why does the infection take a nosedive through July?  Look at Albemarle County
as a case study.

```{r beta.analysis}
## Base transmissibility, without mobility modification
pmap <- MAP(warmups)
loc <- 'AlbemarleCounty'
strtdate <- as.Date('2020-04-01')
enddate <- as.Date('2020-07-31')
dates <- seq(strtdate, enddate, by=1)
times <- dates - as.Date('2020-01-01')

basebeta <- localbeta(pmap, loc)
baser0 <- pmap[['D0']] * basebeta

## Include mobility modifications
mobtbl <- local_mobility(loc)
mobfac <- sapply(times, mobility_adjust,
                 zeta=pmap[['zeta']], mobility_table=mobtbl)
mobr0 <- mobfac*baser0

## Include mask effect
mask <- mask_indicator(times)
maskr0 <- exp(pmap[['mask_effect']] * mask) * mobr0

## Include effects of declining susceptible population
dayzero <- 30
modparm <- as.list(pmap[names(pmap) != 'b'])
modoutput <- run_scenario(seq(0,max(times)+dayzero), modparm, counties = 'AlbemarleCounty')
modoutput$time <- modoutput$time + dayzero
modoutput$date <- modoutput$time + as.Date('2020-01-01')
modoutput$sfrac <- modoutput$S / modoutput$population
filt <- modoutput$time %in% times
modoutput_filt <- modoutput[filt,]
sfrac <- modoutput_filt$sfrac
rt <- maskr0 * sfrac

pltdata <- tibble(t=times, date=dates, mobr0=mobr0, maskr0=maskr0, 
                  sfrac=sfrac, rt=rt)

ggplot(pltdata, aes(x=date)) + 
  geom_line(aes(y=mobr0, color='(b) mobility adjusted R0'),size=1.2) + 
  geom_line(aes(y=maskr0, color='(c) mask + mob R0'), size=1.2) +
  geom_hline(mapping=aes(yintercept=baser0, color='(a) base R0'), size=1.0) +
  geom_line(aes(y=rt, color='(d) Rt'), size=1.2) +
  ylab('R') +
  #coord_cartesian(ylim=c(0,1.25)) +
  ggthemes::scale_color_solarized() +
  theme_bw()
```
